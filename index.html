<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Genesys Cloud - Concurrency & Peak Time Report</title>
  <link href="https://fonts.googleapis.com/css2?family=Aptos:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{
      --primary-color:#63AB8F;
      --secondary-color:#4A8C7D;
      --border-color:#DEE2E6;
      --light-bg:#F8F9FA;
      --card-bg:#FFFFFF;
      --text-color:#2C3E50;
      --text-light:#6C757D;
      --pill:#e9f6f0;
      --filter-bg:#f0f7f3;
      --warning:#ffc107;
      --danger:#dc3545;
      --success:#28a745;
      --info:#17a2b8;
      --peak-color:#dc3545;
      --high-color:#ffc107;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body{
      font-family:'Aptos','Segoe UI',system-ui,-apple-system,Arial,sans-serif;
      margin:20px;
      background:var(--light-bg);
      color:var(--text-color);
      line-height:1.6;
    }
    .container{ max-width:1600px; margin:0 auto; }
    header{
      background:var(--card-bg); border-radius:12px; padding:28px 36px; margin-bottom:28px;
      box-shadow:0 2px 8px rgba(0,0,0,.08); border-left:5px solid var(--primary-color);
      border:1px solid var(--border-color); display:flex; justify-content:space-between;
      align-items:center; flex-wrap:wrap;
    }
    .brand-text {
      display: flex;
      flex-direction: column;
    }
    .brand-main {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    h1{
      color:var(--text-color); font-size:32px; font-weight:600; display:flex;
      align-items:center; gap:12px; margin:0;
    }
    .subtitle{ 
      color:var(--text-light); font-size:17px; margin-top:4px; 
    }
    .main-grid{ display:grid; grid-template-columns:400px 1fr; gap:32px; }
    @media(max-width:1200px){ .main-grid{grid-template-columns:1fr;} }
    .card{
      background:var(--card-bg); border:1px solid var(--border-color); border-radius:14px;
      padding:28px; margin-bottom:24px; box-shadow:0 2px 8px rgba(0,0,0,.05);
    }
    .card h2{
      color:var(--primary-color); margin-bottom:24px; font-size:22px; padding-bottom:16px;
      border-bottom:2px solid var(--light-bg); display:flex; align-items:center; gap:12px; font-weight:600;
    }
    .form-group{margin-bottom:24px;}
    label{ display:block; font-weight:600; margin-bottom:8px; font-size:14px; }
    select,input,button{
      padding:12px; border:1px solid var(--border-color); border-radius:8px; font-size:15px;
      width:100%; font-family:inherit;
    }
    button{
      background:var(--primary-color); color:#fff; font-weight:600; cursor:pointer;
      transition:background .2s; border:none; display:inline-flex; align-items:center;
      justify-content:center; gap:10px; font-size:15px;
    }
    button:hover{background:var(--secondary-color);}
    button:disabled{background:var(--text-light);cursor:not-allowed;}
    .btn-block{width:100%;padding:14px;}
    .btn-success{background:var(--success);}
    .btn-success:hover{background:#218838;}
    .btn-danger{background:var(--danger);}
    .btn-danger:hover{background:#bd2130;}
    .date-range-simple{
      display:flex; flex-direction:column; gap:16px; margin-bottom:20px;
    }
    .date-field-simple{ position:relative; }
    .date-field-simple label{
      display:block; font-weight:600; margin-bottom:8px; font-size:14px;
    }
    .date-field-simple input[type="date"]{
      padding:14px; border:1px solid var(--border-color); border-radius:8px;
      background:var(--card-bg); font-size:15px; width:100%; transition:all 0.3s;
      color:var(--text-color);
    }
    .date-field-simple input[type="date"]:focus{
      outline:none; border-color:var(--primary-color);
      box-shadow:0 0 0 3px rgba(99,171,143,0.1);
    }
    @media (min-width: 768px){
      .date-range-simple{ flex-direction:row; gap:16px; }
      .date-field-simple{ flex:1; }
    }
    .granularity-selector{
      display:grid; grid-template-columns:repeat(4,1fr); gap:12px; margin:20px 0;
    }
    .granularity-option{
      padding:14px 8px; background:var(--light-bg); border:1px solid var(--border-color);
      border-radius:8px; text-align:center; font-weight:600; cursor:pointer;
      transition:all 0.2s; color:var(--text-color);
    }
    .granularity-option:hover{ background:var(--pill); border-color:var(--primary-color); }
    .granularity-option.active{ background:var(--primary-color); color:white; border-color:var(--primary-color); }
    .stats-grid{
      display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:20px; margin-bottom:24px;
    }
    .stat-card{
      background:var(--pill); border-radius:14px; padding:24px; border:1px solid var(--border-color);
      text-align:center; transition:all 0.3s;
    }
    .stat-card:hover{
      transform:translateY(-2px); box-shadow:0 8px 16px rgba(0,0,0,0.1);
      border-color:var(--primary-color);
    }
    .stat-value{
      font-size:38px; font-weight:700; color:var(--primary-color); margin:12px 0;
    }
    .stat-label{
      font-size:15px; color:var(--text-light); text-transform:uppercase; letter-spacing:1px; font-weight:600;
    }
    .peak-stat{ background:rgba(220,53,69,0.1); border-color:rgba(220,53,69,0.3); }
    .peak-stat .stat-value{color:var(--danger);}
    .chart-container{
      background:var(--card-bg); border-radius:12px; padding:20px; margin-top:20px;
      height:400px; position:relative;
    }
    .table-container{
      overflow-x:auto; margin-top:24px; border-radius:10px; border:1px solid var(--border-color);
      background:var(--card-bg); max-height:500px; overflow-y:auto;
    }
    table{width:100%;border-collapse:collapse;}
    th{
      background:var(--primary-color); color:white; font-weight:600; position:sticky; top:0;
      padding:16px; text-align:left; font-size:14px;
    }
    td{padding:14px 16px;border-bottom:1px solid var(--border-color);font-size:14px;}
    tr:hover{background:var(--pill);}
    .peak-badge{
      display:inline-block; padding:6px 14px; border-radius:20px; font-size:13px; font-weight:600;
      background:rgba(220,53,69,0.15); color:var(--danger); border:1px solid rgba(220,53,69,0.3);
    }
    .high-badge{
      background:rgba(255,193,7,0.15); color:#d39e00; border:1px solid rgba(255,193,7,0.3);
    }
    .status-container{
      position:fixed; top:20px; right:20px; z-index:1000; max-width:400px;
    }
    .status-message{
      background:white; padding:16px; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15);
      border-left:4px solid var(--primary-color); margin-bottom:10px; animation:slideIn 0.3s;
      display:flex; align-items:center; gap:12px;
    }
    @keyframes slideIn{ from{transform:translateX(100%);opacity:0;} to{transform:translateX(0);opacity:1;} }
    .loading-overlay{
      position:fixed; top:0;left:0;right:0;bottom:0; background:rgba(255,255,255,0.95);
      display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:9999;
      display:none;
    }
    .loading-overlay.active{display:flex;}
    .spinner{
      width:60px;height:60px; border:5px solid #f3f3f3; border-top:5px solid var(--primary-color);
      border-radius:50%; animation:spin 1s linear infinite; margin-bottom:20px;
    }
    @keyframes spin{to{transform:rotate(360deg);}}
    .progress-bar{
      width:100%; max-width:500px; height:10px; background:var(--light-bg);
      border-radius:5px; margin-top:20px; overflow:hidden;
    }
    .progress-fill{
      height:100%; background:linear-gradient(90deg,var(--primary-color),var(--secondary-color));
      width:0%; transition:width 0.3s;
    }
    .peak-time-grid{
      display:grid; grid-template-columns:repeat(auto-fit,minmax(300px,1fr)); gap:20px; margin-bottom:24px;
    }
    .peak-card{
      background:white; border-radius:14px; padding:24px; border:1px solid var(--border-color);
      box-shadow:0 2px 8px rgba(0,0,0,.05);
    }
    .peak-time{ font-size:28px; font-weight:700; color:var(--danger); margin:12px 0; }
    .connection-status{
      display:flex; align-items:center; gap:12px; background:var(--light-bg);
      padding:12px 24px; border-radius:30px;
    }
    .status-indicator{ width:14px; height:14px; border-radius:50%; background:var(--text-light); }
    .connected .status-indicator{background:var(--success);}
    .footer{ margin-top:30px; padding:20px; text-align:center; color:var(--text-light); font-size:13px; }
    .info-box{
      background:rgba(99,171,143,0.05); border-radius:8px; padding:16px; margin-top:16px;
      font-size:13px; color:var(--text-light);
    }
    .brand { display: flex; align-items: center; gap: 15px; }
    .brand-logo { height: 40px; object-fit: contain; }
    .divider { border: none; height: 1px; background: var(--border-color); margin: 0; }
    .region-badge {
      background: var(--info);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      margin-left: 12px;
      display: inline-block;
    }
    .debug-info {
      font-size: 11px;
      color: var(--text-light);
      margin-top: 10px;
      padding: 8px;
      background: var(--light-bg);
      border-radius: 4px;
      font-family: monospace;
      max-height: 200px;
      overflow-y: auto;
    }
    .interval-progress {
      margin-top: 10px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="app-content" style="width:100%;height:100%;flex:1;display:flex;flex-direction:column;">
    <header>
      <div class="brand">
        <img src="https://raw.githubusercontent.com/gmcglynn88/TimeoffApp/main/YourTime%20Logo_WEM_White%20Reversed.png" alt="Your Time" class="brand-logo">
        <div class="brand-text">
          <div class="brand-main">
            <h1>üìä Concurrency & Peak Time Report</h1>
            <span class="region-badge">üá¨üáß LONDON</span>
          </div>
          <div class="subtitle">Genesys Cloud - London Region (apps.euw2.pure.cloud)</div>
        </div>
      </div>
      <div class="connection-status" id="connectionStatus">
        <span class="status-indicator" id="statusIndicator"></span>
        <span id="statusText">Initialising...</span>
      </div>
    </header>
    <hr class="divider">

    <div class="main-content">
      <div class="container" style="width:100%;padding:20px;">
        <div class="main-grid">
          <!-- Left Column - Controls -->
          <div class="left-column">
            <div class="card">
              <h2>üìÖ Analysis Period</h2>
              <div class="date-range-simple">
                <div class="date-field-simple">
                  <label for="dateFrom">From Date</label>
                  <input type="date" id="dateFrom" required>
                </div>
                <div class="date-field-simple">
                  <label for="dateTo">To Date</label>
                  <input type="date" id="dateTo" required>
                </div>
              </div>
              <div id="dateRangeInfo" style="font-size:13px;color:var(--text-light);text-align:center;margin-top:12px;padding:10px;background:var(--pill);border-radius:6px;">
                Last 7 days selected
              </div>
            </div>

            <div class="card">
              <h2>‚è±Ô∏è Granularity</h2>
              <div class="granularity-selector" id="granularitySelector">
                <div class="granularity-option active" data-granularity="PT15M">15m</div>
                <div class="granularity-option" data-granularity="PT30M">30m</div>
                <div class="granularity-option" data-granularity="PT60M">1h</div>
                <div class="granularity-option" data-granularity="P1D">Daily</div>
              </div>
              <div class="granularity-note" style="font-size:12px;color:var(--text-light);margin-top:8px;">
                ‚ìò Each interval is queried separately for accurate counts
              </div>
              
              <div style="margin-top:24px;">
                <label for="thresholdConcurrency">Concurrency Alert Threshold</label>
                <input type="number" id="thresholdConcurrency" value="20" min="1" max="1000">
                <div style="font-size:13px;color:var(--text-light);margin-top:6px;">
                  Highlight intervals exceeding this concurrent logged-in user count
                </div>
              </div>
            </div>

            <div class="card">
              <h2>üöÄ Actions</h2>
              <button id="btnFetchUsers" class="btn-block" style="margin-bottom:16px;" disabled>
                üë• 1. Fetch Users
              </button>
              <button id="btnFetchConcurrency" class="btn-success btn-block" style="margin-bottom:16px;" disabled>
                üìä 2. Analyse Concurrency
              </button>
              <button id="btnExport" class="btn-block" style="margin-bottom:16px;background:var(--text-light);" disabled>
                üì• Export Peak Report
              </button>
              <button id="btnReset" class="btn-danger btn-block">
                üîÑ Reset Session
              </button>
              
              <!-- Manual Authentication Button -->
              <button id="btnManualAuth" class="btn-block" style="margin-bottom:16px;background:var(--info);">
                üîê Re-authenticate
              </button>
              
              <div class="info-box" style="margin-top:24px;">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:12px;">
                  <span style="background:var(--primary-color);color:white;padding:2px 12px;border-radius:20px;font-size:12px;">OAuth Settings</span>
                </div>
                <div style="font-size:12px;">
                  <strong>Client ID:</strong> d968eca4-cdb7-4b90-91b1-4628b5bb679e<br>
                  <strong>Redirect URI:</strong> <span id="currentRedirectUri"></span><br>
                  <strong>Environment:</strong> login.euw2.pure.cloud
                </div>
              </div>

              <div class="info-box" style="margin-top:24px;background:rgba(40,167,69,0.05);">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:12px;">
                  <span style="background:var(--success);color:white;padding:2px 12px;border-radius:20px;font-size:12px;">‚úÖ INTERVAL COUNTING</span>
                </div>
                <ul style="list-style-type:none;padding-left:0;">
                  <li style="margin-bottom:8px;">‚úÖ Each 15min interval queried separately</li>
                  <li style="margin-bottom:8px;">‚úÖ Users counted if present in that interval</li>
                  <li style="margin-bottom:8px;">‚úÖ Higher granularities aggregate from 15min data</li>
                </ul>
              </div>
              
              <!-- Debug info -->
              <div id="debugInfo" class="debug-info" style="display:block;">
                <strong>Debug:</strong> Ready to analyze...
              </div>
              <div id="intervalProgress" class="interval-progress"></div>
            </div>
          </div>

          <!-- Right Column - Results -->
          <div class="right-column">
            <!-- Key Stats -->
            <div class="stats-grid">
              <div class="stat-card">
                <div class="stat-label">Total Users</div>
                <div class="stat-value" id="statTotalUsers">0</div>
                <div style="font-size:12px;color:var(--text-light);">Active licensed users</div>
              </div>
              <div class="stat-card peak-stat">
                <div class="stat-label">Peak Concurrency</div>
                <div class="stat-value" id="statPeakConcurrency">0</div>
                <div style="font-size:12px;color:var(--text-light);">Max concurrent logged-in</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Avg Concurrency</div>
                <div class="stat-value" id="statAvgConcurrency">0</div>
                <div style="font-size:12px;color:var(--text-light);">Period average</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Total Intervals</div>
                <div class="stat-value" id="statTotalIntervals">0</div>
                <div style="font-size:12px;color:var(--text-light);">Time slices analysed</div>
              </div>
            </div>

            <!-- Peak Times Cards -->
            <div class="peak-time-grid">
              <div class="peak-card">
                <div style="display:flex;align-items:center;gap:8px;">
                  <span style="font-size:24px;">üèÜ</span>
                  <h3 style="margin:0;font-size:18px;color:var(--text-color);">Overall Peak</h3>
                </div>
                <div class="peak-time" id="peakTimeOverall">--:--</div>
                <div style="color:var(--text-light);" id="peakConcurrencyOverall">0 concurrent users</div>
              </div>
              <div class="peak-card">
                <div style="display:flex;align-items:center;gap:8px;">
                  <span style="font-size:24px;">üìÖ</span>
                  <h3 style="margin:0;font-size:18px;color:var(--text-color);">Peak Day</h3>
                </div>
                <div class="peak-time" id="peakDay">--/--/----</div>
                <div style="color:var(--text-light);" id="peakDayConcurrency">0 concurrent users</div>
              </div>
              <div class="peak-card">
                <div style="display:flex;align-items:center;gap:8px;">
                  <span style="font-size:24px;">‚è∞</span>
                  <h3 style="margin:0;font-size:18px;color:var(--text-color);">Busiest Hour</h3>
                </div>
                <div class="peak-time" id="peakHour">--:--</div>
                <div style="color:var(--text-light);" id="peakHourConcurrency">0 concurrent users</div>
              </div>
            </div>

            <!-- Concurrency Chart -->
            <div class="card">
              <h2>üìä Concurrency Over Time</h2>
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
                <span id="granularityLabel" style="font-weight:600;color:var(--primary-color);background:var(--pill);padding:8px 16px;border-radius:20px;">15-minute intervals</span>
                <span style="background:rgba(220,53,69,0.1);padding:8px 16px;border-radius:20px;font-size:13px;font-weight:600;">Alert threshold: <span id="thresholdValue" style="color:var(--danger);">20</span> users</span>
              </div>
              <div class="chart-container">
                <canvas id="concurrencyChart"></canvas>
              </div>
            </div>

            <!-- Peak Intervals Table -->
            <div class="card">
              <h2>‚ö†Ô∏è Peak Intervals (Exceeding Threshold)</h2>
              <div class="table-container">
                <table id="peakTable">
                  <thead>
                    <tr>
                      <th>Date & Time (UTC)</th>
                      <th>Concurrent Users</th>
                      <th>% of Peak</th>
                      <th>Status</th>
                    </tr>
                  </thead>
                  <tbody id="peakTableBody">
                    <tr>
                      <td colspan="4" style="text-align:center;padding:48px;color:var(--text-light);">
                        No data yet. Fetch users and run concurrency analysis.
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>

            <!-- All Intervals Data -->
            <div class="card">
              <h2>üìã All Intervals</h2>
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
                <input type="text" id="searchInterval" placeholder="üîç Search date/time..." style="max-width:300px;padding:12px;">
                <span style="font-size:13px;color:var(--text-light);background:var(--pill);padding:8px 16px;border-radius:20px;">
                  Showing <span id="visibleIntervals">0</span>/<span id="totalIntervals">0</span> intervals
                </span>
              </div>
              <div class="table-container" style="max-height:400px;">
                <table id="intervalsTable">
                  <thead>
                    <tr>
                      <th>Interval Start (UTC)</th>
                      <th>Concurrent Users</th>
                      <th>Change</th>
                    </tr>
                  </thead>
                  <tbody id="intervalsTableBody">
                    <tr>
                      <td colspan="3" style="text-align:center;padding:48px;color:var(--text-light);">
                        No data available.
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingText" style="font-size:20px;font-weight:600;margin-bottom:12px;">Loading...</div>
    <div id="loadingSubtext" style="font-size:15px;color:var(--text-light);text-align:center;max-width:500px;"></div>
    <div class="progress-bar">
      <div class="progress-fill" id="loadingProgressFill"></div>
    </div>
  </div>

  <div class="status-container" id="statusContainer"></div>

  <script>
    // ==================== LONDON REGION CONFIGURATION ====================
    const CLIENT_ID = 'd968eca4-cdb7-4b90-91b1-4628b5bb679e';
    const REDIRECT_URI = 'https://gmcglynn88.github.io/ConcurrencyReporting/';
    
    const ENVIRONMENTS = {
      'eu-west-2': { 
        name: 'London (EU West 2)', 
        api: 'https://api.euw2.pure.cloud', 
        login: 'https://login.euw2.pure.cloud' 
      }
    };

    const STORAGE_KEYS = {
      ENVIRONMENT: 'gc_concurrency_london_env_v8',
      TOKEN: 'gc_concurrency_london_token_v8',
      TOKEN_EXPIRY: 'gc_concurrency_london_expiry_v8',
      DATE_FROM: 'gc_concurrency_london_date_from_v8',
      DATE_TO: 'gc_concurrency_london_date_to_v8',
      GRANULARITY: 'gc_concurrency_london_granularity_v8',
      THRESHOLD: 'gc_concurrency_london_threshold_v8'
    };

    // ==================== APP STATE ====================
    let appState = {
      isConnected: false,
      token: null,
      tokenExpiry: null,
      environment: ENVIRONMENTS['eu-west-2'],
      users: [],
      fifteenMinData: [], // Stores data for each 15-min interval
      aggregatedData: [], // Stores data at selected granularity
      stats: {
        totalUsers: 0,
        peakConcurrency: 0,
        avgConcurrency: 0,
        totalIntervals: 0,
        peakInterval: null
      },
      currentGranularity: 'PT15M',
      threshold: 20,
      chart: null
    };

    // ==================== DOM ELEMENTS ====================
    const el = {
      mainContent: document.getElementById('app-content'),
      statusIndicator: document.getElementById('statusIndicator'),
      statusText: document.getElementById('statusText'),
      dateFrom: document.getElementById('dateFrom'),
      dateTo: document.getElementById('dateTo'),
      dateRangeInfo: document.getElementById('dateRangeInfo'),
      thresholdConcurrency: document.getElementById('thresholdConcurrency'),
      granularityOptions: document.querySelectorAll('.granularity-option'),
      statTotalUsers: document.getElementById('statTotalUsers'),
      statPeakConcurrency: document.getElementById('statPeakConcurrency'),
      statAvgConcurrency: document.getElementById('statAvgConcurrency'),
      statTotalIntervals: document.getElementById('statTotalIntervals'),
      peakTimeOverall: document.getElementById('peakTimeOverall'),
      peakConcurrencyOverall: document.getElementById('peakConcurrencyOverall'),
      peakDay: document.getElementById('peakDay'),
      peakDayConcurrency: document.getElementById('peakDayConcurrency'),
      peakHour: document.getElementById('peakHour'),
      peakHourConcurrency: document.getElementById('peakHourConcurrency'),
      granularityLabel: document.getElementById('granularityLabel'),
      thresholdValue: document.getElementById('thresholdValue'),
      peakTableBody: document.getElementById('peakTableBody'),
      intervalsTableBody: document.getElementById('intervalsTableBody'),
      btnFetchUsers: document.getElementById('btnFetchUsers'),
      btnFetchConcurrency: document.getElementById('btnFetchConcurrency'),
      btnExport: document.getElementById('btnExport'),
      btnReset: document.getElementById('btnReset'),
      btnManualAuth: document.getElementById('btnManualAuth'),
      searchInterval: document.getElementById('searchInterval'),
      visibleIntervals: document.getElementById('visibleIntervals'),
      totalIntervals: document.getElementById('totalIntervals'),
      loadingOverlay: document.getElementById('loadingOverlay'),
      loadingText: document.getElementById('loadingText'),
      loadingSubtext: document.getElementById('loadingSubtext'),
      loadingProgressFill: document.getElementById('loadingProgressFill'),
      statusContainer: document.getElementById('statusContainer'),
      concurrencyChart: document.getElementById('concurrencyChart'),
      currentRedirectUri: document.getElementById('currentRedirectUri'),
      debugInfo: document.getElementById('debugInfo'),
      intervalProgress: document.getElementById('intervalProgress')
    };

    if (el.currentRedirectUri) {
      el.currentRedirectUri.textContent = REDIRECT_URI;
    }

    // ==================== AUTHENTICATION ====================
    function parseTokenFromHash() {
      const hash = window.location.hash.replace(/^#/, '');
      if (!hash) return {};
      const params = new URLSearchParams(hash);
      return {
        token: params.get('access_token'),
        error: params.get('error'),
        errorDescription: params.get('error_description'),
        expiresIn: params.get('expires_in')
      };
    }

    function saveCredentials(token, expiresIn) {
      try {
        const tokenExpiry = Date.now() + (parseInt(expiresIn, 10) * 1000);
        appState.token = token;
        appState.tokenExpiry = tokenExpiry;
        appState.isConnected = true;
        appState.environment = ENVIRONMENTS['eu-west-2'];
        localStorage.setItem(STORAGE_KEYS.TOKEN, token);
        localStorage.setItem(STORAGE_KEYS.TOKEN_EXPIRY, tokenExpiry.toString());
        localStorage.setItem(STORAGE_KEYS.ENVIRONMENT, 'eu-west-2');
        return true;
      } catch (e) {
        console.error('Failed to save credentials:', e);
        return false;
      }
    }

    function loadStoredCredentials() {
      try {
        const token = localStorage.getItem(STORAGE_KEYS.TOKEN);
        const tokenExpiry = localStorage.getItem(STORAGE_KEYS.TOKEN_EXPIRY);
        const environment = localStorage.getItem(STORAGE_KEYS.ENVIRONMENT);
        if (token && tokenExpiry && environment) {
          const expiry = parseInt(tokenExpiry, 10);
          if (Date.now() < expiry) {
            appState.token = token;
            appState.tokenExpiry = expiry;
            appState.isConnected = true;
            appState.environment = ENVIRONMENTS['eu-west-2'];
            return true;
          } else {
            localStorage.removeItem(STORAGE_KEYS.TOKEN);
            localStorage.removeItem(STORAGE_KEYS.TOKEN_EXPIRY);
            localStorage.removeItem(STORAGE_KEYS.ENVIRONMENT);
          }
        }
      } catch (e) {
        console.warn('Failed to load stored credentials:', e);
      }
      return false;
    }

    function clearCredentials() {
      try {
        localStorage.removeItem(STORAGE_KEYS.TOKEN);
        localStorage.removeItem(STORAGE_KEYS.TOKEN_EXPIRY);
        localStorage.removeItem(STORAGE_KEYS.ENVIRONMENT);
        localStorage.removeItem(STORAGE_KEYS.DATE_FROM);
        localStorage.removeItem(STORAGE_KEYS.DATE_TO);
        localStorage.removeItem(STORAGE_KEYS.GRANULARITY);
        localStorage.removeItem(STORAGE_KEYS.THRESHOLD);
        appState.token = null;
        appState.tokenExpiry = null;
        appState.isConnected = false;
        appState.users = [];
        appState.fifteenMinData = [];
        appState.aggregatedData = [];
      } catch (e) {
        console.error('Failed to clear credentials:', e);
      }
    }

    function authUrl() {
      const baseUrl = ENVIRONMENTS['eu-west-2'].login;
      const clientId = encodeURIComponent(CLIENT_ID);
      const redirectUri = encodeURIComponent(REDIRECT_URI);
      return `${baseUrl}/oauth/authorize?client_id=${clientId}&response_type=token&redirect_uri=${redirectUri}`;
    }

    function initAuth() {
      console.log("Initializing London region authentication...");
      const { token, error, errorDescription, expiresIn } = parseTokenFromHash();
      
      if (window.location.hash) {
        history.replaceState(null, '', window.location.pathname + window.location.search);
      }
      
      if (token) {
        saveCredentials(token, expiresIn || '3600');
        updateConnectionStatus(true);
        showStatusMessage('‚úÖ Authentication successful - London Region', 'success');
        return;
      }
      
      if (error) {
        showStatusMessage(`‚ùå Authentication failed: ${errorDescription || error}`, 'error');
      }
      
      if (loadStoredCredentials()) {
        updateConnectionStatus(true);
        showStatusMessage('‚úÖ Authenticated with stored credentials - London Region', 'success');
        return;
      }
      
      if (!token && !error && !loadStoredCredentials()) {
        window.location.href = authUrl();
      }
    }

    function manualAuth() {
      clearCredentials();
      window.location.href = authUrl();
    }

    // ==================== UTILITIES ====================
    function showStatusMessage(message, type = 'info') {
      const msgDiv = document.createElement('div');
      msgDiv.className = 'status-message';
      const icon = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warn' ? '‚ö†Ô∏è' : 'üí°';
      const color = type === 'success' ? 'var(--success)' : type === 'error' ? 'var(--danger)' : type === 'warn' ? 'var(--warning)' : 'var(--info)';
      msgDiv.style.borderLeftColor = color;
      msgDiv.innerHTML = `<span style="font-size:20px;">${icon}</span><div><div style="font-weight:600;">${message}</div><div style="font-size:12px;color:var(--text-light);">${new Date().toLocaleTimeString()}</div></div>`;
      document.getElementById('statusContainer').appendChild(msgDiv);
      setTimeout(() => { if (msgDiv.parentNode) { msgDiv.style.opacity = '0'; msgDiv.style.transform = 'translateX(100%)'; setTimeout(() => msgDiv.remove(), 300); } }, 5000);
    }

    function setLoading(show, text = '', subtext = '') {
      if (show) {
        el.loadingText.textContent = text;
        el.loadingSubtext.textContent = subtext;
        el.loadingOverlay.classList.add('active');
      } else {
        el.loadingOverlay.classList.remove('active');
      }
    }

    function updateLoadingProgress(percent) {
      el.loadingProgressFill.style.width = `${percent}%`;
    }

    function updateConnectionStatus(connected) {
      appState.isConnected = connected;
      if (el.statusIndicator) {
        el.statusIndicator.style.background = connected ? 'var(--success)' : 'var(--danger)';
      }
      if (el.statusText) {
        el.statusText.textContent = connected ? 'Connected to London (euw2)' : 'Not Connected';
        el.statusText.style.color = connected ? 'var(--success)' : 'var(--danger)';
      }
      if (el.btnFetchUsers) {
        el.btnFetchUsers.disabled = !connected;
      }
    }

    function formatIntervalDate(intervalStr, granularity) {
      try {
        const parts = intervalStr.split('/');
        const start = new Date(parts[0]);
        if (granularity === 'P1D') {
          return start.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric', timeZone: 'UTC' });
        } else {
          return start.toLocaleString('en-GB', { 
            day: '2-digit', 
            month: 'short', 
            hour: '2-digit', 
            minute: '2-digit', 
            hour12: false,
            timeZone: 'UTC' 
          }).replace(',', '');
        }
      } catch (e) {
        return intervalStr;
      }
    }

    function formatHourFromInterval(intervalStr) {
      try {
        const start = new Date(intervalStr.split('/')[0]);
        return start.toISOString().substring(11, 16);
      } catch (e) {
        return '--:--';
      }
    }

    function formatDateFromInterval(intervalStr) {
      try {
        const start = new Date(intervalStr.split('/')[0]);
        return start.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric', timeZone: 'UTC' });
      } catch (e) {
        return '--/--/----';
      }
    }

    function getLast7Days() {
      const today = new Date();
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(today.getDate() - 7);
      return { from: sevenDaysAgo.toISOString().split('T')[0], to: today.toISOString().split('T')[0] };
    }

    function updateDateRangeInfo() {
      const fromDate = el.dateFrom.value;
      const toDate = el.dateTo.value;
      if (fromDate && toDate) {
        const start = new Date(fromDate);
        const end = new Date(toDate);
        const diffTime = Math.abs(end - start);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
        el.dateRangeInfo.innerHTML = `<strong>Selected:</strong> ${formatDateFromInterval(fromDate+'T00:00:00.000Z/')} to ${formatDateFromInterval(toDate+'T00:00:00.000Z/')} (${diffDays} days)`;
        if (diffDays > 7) {
          el.dateRangeInfo.innerHTML += '<br><span style="color:var(--warning);">‚ö†Ô∏è Range >7 days - will be split into 7-day windows</span>';
        }
      }
    }

    // ==================== API CALLS ====================
    async function apiCall(path, options = {}) {
      if (!appState.isConnected || !appState.token) {
        throw new Error('Not authenticated');
      }
      if (Date.now() > appState.tokenExpiry) {
        clearCredentials();
        throw new Error('Token expired. Please reconnect.');
      }
      const url = `${appState.environment.api}${path}`;
      const response = await fetch(url, {
        ...options,
        headers: {
          'Authorization': `Bearer ${appState.token}`,
          'Content-Type': 'application/json',
          ...options.headers
        }
      });
      if (response.status === 401) {
        clearCredentials();
        throw new Error('Authentication expired. Please reconnect.');
      }
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After') || 5;
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        return apiCall(path, options);
      }
      if (!response.ok) {
        throw new Error(`API Error: ${response.status} ${response.statusText}`);
      }
      return response.json();
    }

    // ==================== FETCH USERS ====================
    async function fetchUsers() {
      if (!appState.isConnected) {
        showStatusMessage('Please connect first', 'error');
        return;
      }
      setLoading(true, 'Fetching Users', 'Retrieving all active users from Genesys Cloud London...');
      updateLoadingProgress(10);
      try {
        let allUsers = [];
        let page = 1;
        const pageSize = 100;
        while (true) {
          updateLoadingProgress(10 + (page * 5));
          const response = await apiCall(`/api/v2/users?pageSize=${pageSize}&pageNumber=${page}&state=active`);
          allUsers = allUsers.concat(response.entities || []);
          if (!response.nextUri || response.entities.length < pageSize) { break; }
          page++;
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        appState.users = allUsers;
        appState.stats.totalUsers = allUsers.length;
        el.statTotalUsers.textContent = allUsers.length;
        showStatusMessage(`‚úÖ Fetched ${allUsers.length} active users from London`, 'success');
        el.btnFetchConcurrency.disabled = false;
        updateLoadingProgress(100);
        setTimeout(() => setLoading(false), 500);
      } catch (error) {
        setLoading(false);
        showStatusMessage(`‚ùå Failed to fetch users: ${error.message}`, 'error');
      }
    }

    // ==================== CHECK IF USER IS LOGGED IN DURING INTERVAL ====================
    function isUserLoggedInDuringInterval(presenceEvents, intervalStart, intervalEnd) {
      // User is considered logged in if they have ANY non-Offline presence during the interval
      for (const presence of presenceEvents) {
        if (presence.systemPresence && presence.systemPresence !== 'Offline') {
          const presenceStart = new Date(presence.startTime);
          const presenceEnd = presence.endTime ? new Date(presence.endTime) : new Date(presenceStart.getTime() + (4 * 60 * 60 * 1000));
          
          // Check if presence overlaps with interval
          if (presenceStart < intervalEnd && presenceEnd > intervalStart) {
            return true;
          }
        }
      }
      return false;
    }

    // ==================== GENERATE 15-MINUTE INTERVALS ====================
    function generate15MinIntervals(dateFrom, dateTo) {
      const intervals = [];
      const start = new Date(`${dateFrom}T00:00:00.000Z`);
      const end = new Date(`${dateTo}T23:59:59.999Z`);
      let current = new Date(start);
      const intervalMs = 15 * 60 * 1000; // 15 minutes
      
      while (current < end) {
        const intervalEnd = new Date(Math.min(current.getTime() + intervalMs, end.getTime()));
        intervals.push({
          interval: `${current.toISOString()}/${intervalEnd.toISOString()}`,
          start: new Date(current),
          end: new Date(intervalEnd),
          startTime: current.toISOString(),
          endTime: intervalEnd.toISOString()
        });
        current = new Date(intervalEnd);
      }
      
      return intervals;
    }

    // ==================== FETCH CONCURRENCY - INTERVAL BY INTERVAL ====================
    async function fetchConcurrency() {
      if (!appState.users.length) {
        showStatusMessage('Please fetch users first', 'error');
        return;
      }

      setLoading(true, 'Analysing Concurrency', 'Processing intervals one by one...');
      updateLoadingProgress(5);

      try {
        const dateFrom = el.dateFrom.value;
        const dateTo = el.dateTo.value;
        
        if (!dateFrom || !dateTo) {
          throw new Error('Please select a date range');
        }

        const userIds = appState.users.map(u => u.id);
        const batchSize = 50; // Number of users to query at once
        
        // Generate all 15-minute intervals
        const fifteenMinIntervals = generate15MinIntervals(dateFrom, dateTo);
        const totalIntervals = fifteenMinIntervals.length;
        
        // Store results for each interval
        const intervalResults = [];
        
        // Process each interval separately
        for (let intervalIdx = 0; intervalIdx < fifteenMinIntervals.length; intervalIdx++) {
          const interval = fifteenMinIntervals[intervalIdx];
          
          // Update progress
          const intervalProgress = Math.round((intervalIdx / totalIntervals) * 100);
          updateLoadingProgress(5 + (intervalProgress * 0.9)); // Scale to 95%
          
          el.loadingSubtext.innerHTML = `Processing interval ${intervalIdx + 1}/${totalIntervals}: ${interval.startTime.substring(11,16)}-${interval.endTime.substring(11,16)}`;
          
          if (el.intervalProgress) {
            el.intervalProgress.innerHTML = `Interval ${intervalIdx + 1}/${totalIntervals}: ${interval.startTime.substring(11,16)}-${interval.endTime.substring(11,16)}`;
          }
          
          // Set to track unique logged-in users for this interval
          const loggedInUsers = new Set();
          
          // Process users in batches for this interval
          for (let i = 0; i < userIds.length; i += batchSize) {
            const batch = userIds.slice(i, i + batchSize);
            
            // Query for this batch in this specific interval
            const queryBody = {
              interval: interval.interval,
              userFilters: [{
                type: 'or',
                predicates: batch.map(userId => ({
                  type: 'dimension',
                  dimension: 'userId',
                  value: userId
                }))
              }],
              paging: {
                pageSize: 100,
                pageNumber: 1
              }
            };

            try {
              const response = await apiCall('/api/v2/analytics/users/details/query', {
                method: 'POST',
                body: JSON.stringify(queryBody)
              });

              if (response.userDetails) {
                response.userDetails.forEach(userDetail => {
                  const userId = userDetail.userId;
                  
                  // Check if user has any non-Offline presence in this interval
                  if (userDetail.primaryPresence && userDetail.primaryPresence.length > 0) {
                    let isLoggedIn = false;
                    
                    for (const presence of userDetail.primaryPresence) {
                      if (presence.systemPresence && presence.systemPresence !== 'Offline') {
                        isLoggedIn = true;
                        break;
                      }
                    }
                    
                    if (isLoggedIn) {
                      loggedInUsers.add(userId);
                    }
                  }
                });
              }
            } catch (batchError) {
              console.warn(`Interval ${intervalIdx}, batch failed:`, batchError);
            }

            // Small delay to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          
          // Store result for this interval
          intervalResults.push({
            interval: interval.interval,
            concurrent: loggedInUsers.size,
            date: new Date(interval.start),
            startTime: interval.startTime,
            endTime: interval.endTime
          });
        }

        updateLoadingProgress(95);

        // Sort by date
        intervalResults.sort((a, b) => a.date - b.date);
        
        // Store the 15-minute base data
        appState.fifteenMinData = intervalResults;
        
        // Aggregate to selected granularity
        appState.aggregatedData = aggregateToGranularity(intervalResults, appState.currentGranularity);
        
        // Calculate stats
        let peakConcurrency = 0;
        let totalConcurrency = 0;
        
        appState.aggregatedData.forEach(item => {
          totalConcurrency += item.concurrent;
          if (item.concurrent > peakConcurrency) peakConcurrency = item.concurrent;
        });
        
        appState.stats.peakConcurrency = peakConcurrency;
        appState.stats.avgConcurrency = appState.aggregatedData.length > 0 ? Math.round(totalConcurrency / appState.aggregatedData.length) : 0;
        appState.stats.totalIntervals = appState.aggregatedData.length;
        
        // Calculate stats for debug
        const nonZeroIntervals = appState.aggregatedData.filter(d => d.concurrent > 0).length;
        
        // Calculate changes between intervals
        let changes = 0;
        for (let i = 1; i < appState.aggregatedData.length; i++) {
          if (appState.aggregatedData[i].concurrent !== appState.aggregatedData[i-1].concurrent) {
            changes++;
          }
        }
        const variancePercentage = appState.aggregatedData.length > 1 ? (changes / (appState.aggregatedData.length - 1)) * 100 : 0;
        
        // Update debug info
        if (el.debugInfo) {
          el.debugInfo.innerHTML = `
            <strong>Interval-by-Interval Results:</strong><br>
            15min intervals processed: ${intervalResults.length}<br>
            15min peak: ${Math.max(...intervalResults.map(d => d.concurrent))}<br>
            <br><strong>${appState.currentGranularity} Aggregated:</strong><br>
            Intervals: ${appState.aggregatedData.length}<br>
            Peak: ${peakConcurrency}<br>
            Avg: ${appState.stats.avgConcurrency}<br>
            Non-zero: ${nonZeroIntervals}<br>
            Changes: ${changes} (${variancePercentage.toFixed(1)}% vary)<br>
            Sample 15min data: ${intervalResults.slice(0, 3).map(d => d.concurrent).join(', ')}...<br>
            Sample aggregated: ${appState.aggregatedData.slice(0, 3).map(d => d.concurrent).join(', ')}...
          `;
        }
        
        calculatePeakTimes();
        updateStatsUI();
        renderConcurrencyChart();
        renderPeakTable();
        renderIntervalsTable();
        
        el.btnExport.disabled = false;
        
        updateLoadingProgress(100);
        setTimeout(() => setLoading(false), 500);
        
        showStatusMessage(`‚úÖ Analysis complete - Processed ${intervalResults.length} intervals individually`, 'success');
        
        console.log('First 10 intervals:', intervalResults.slice(0, 10));
        
      } catch (error) {
        setLoading(false);
        showStatusMessage(`‚ùå Failed to analyse concurrency: ${error.message}`, 'error');
        console.error('Concurrency error:', error);
      }
    }

    // ==================== AGGREGATE TO HIGHER GRANULARITY ====================
    function aggregateToGranularity(fifteenMinData, targetGranularity) {
      if (targetGranularity === 'PT15M') {
        return fifteenMinData; // No aggregation needed
      }
      
      const aggregated = [];
      let incrementMinutes;
      let intervalsPerAggregate;
      
      switch(targetGranularity) {
        case 'PT30M': 
          incrementMinutes = 30; 
          intervalsPerAggregate = 2;
          break;
        case 'PT60M': 
          incrementMinutes = 60; 
          intervalsPerAggregate = 4;
          break;
        case 'P1D': 
          incrementMinutes = 24 * 60; 
          intervalsPerAggregate = 96; // 24 hours * 4 intervals per hour
          break;
        default: 
          return fifteenMinData;
      }
      
      for (let i = 0; i < fifteenMinData.length; i += intervalsPerAggregate) {
        const chunk = fifteenMinData.slice(i, i + intervalsPerAggregate);
        if (chunk.length === 0) continue;
        
        // Use the MAX concurrency during the aggregated period
        // This shows the peak load during that time
        const maxConcurrent = Math.max(...chunk.map(d => d.concurrent));
        
        // Use the first interval's start time for the aggregated interval
        aggregated.push({
          interval: chunk[0].interval,
          concurrent: maxConcurrent,
          date: new Date(chunk[0].date),
          sourceIntervals: chunk.length
        });
      }
      
      return aggregated;
    }

    // ==================== CALCULATE PEAK TIMES ====================
    function calculatePeakTimes() {
      const displayData = appState.aggregatedData;
      if (displayData.length === 0) return;
      
      const peak = displayData.reduce((max, curr) => curr.concurrent > max.concurrent ? curr : max);
      appState.stats.peakInterval = peak.interval;
      
      const peakDate = new Date(peak.interval.split('/')[0]);
      el.peakTimeOverall.textContent = peakDate.toLocaleString('en-GB', { 
        hour: '2-digit', 
        minute: '2-digit', 
        hour12: false,
        timeZone: 'UTC' 
      });
      el.peakConcurrencyOverall.textContent = `${peak.concurrent} concurrent users`;
      
      const dayMap = new Map();
      displayData.forEach(item => {
        const day = formatDateFromInterval(item.interval);
        if (!dayMap.has(day) || item.concurrent > dayMap.get(day)) { 
          dayMap.set(day, item.concurrent); 
        }
      });
      
      let peakDay = null, peakDayValue = 0;
      dayMap.forEach((value, day) => { 
        if (value > peakDayValue) { 
          peakDayValue = value; 
          peakDay = day; 
        } 
      });
      
      el.peakDay.textContent = peakDay || '--/--/----';
      el.peakDayConcurrency.textContent = `${peakDayValue} concurrent users`;
      
      if (appState.currentGranularity !== 'P1D') {
        const hourMap = new Map();
        displayData.forEach(item => {
          const hour = formatHourFromInterval(item.interval);
          if (!hourMap.has(hour) || item.concurrent > hourMap.get(hour)) { 
            hourMap.set(hour, item.concurrent); 
          }
        });
        
        let peakHour = null, peakHourValue = 0;
        hourMap.forEach((value, hour) => { 
          if (value > peakHourValue) { 
            peakHourValue = value; 
            peakHour = hour; 
          } 
        });
        
        el.peakHour.textContent = peakHour || '--:--';
        el.peakHourConcurrency.textContent = `${peakHourValue} concurrent users`;
      } else {
        el.peakHour.textContent = '--:--';
        el.peakHourConcurrency.textContent = 'Not available for daily granularity';
      }
    }

    // ==================== UI RENDERING ====================
    function updateStatsUI() {
      el.statPeakConcurrency.textContent = appState.stats.peakConcurrency;
      el.statAvgConcurrency.textContent = appState.stats.avgConcurrency;
      el.statTotalIntervals.textContent = appState.stats.totalIntervals;
      el.thresholdValue.textContent = appState.threshold;
      
      let granularityText = '15-minute';
      if (appState.currentGranularity === 'PT15M') granularityText = '15-minute';
      else if (appState.currentGranularity === 'PT30M') granularityText = '30-minute';
      else if (appState.currentGranularity === 'PT60M') granularityText = '1-hour';
      else if (appState.currentGranularity === 'P1D') granularityText = 'daily';
      el.granularityLabel.textContent = `${granularityText} intervals (peak per period)`;
    }

    function renderConcurrencyChart() {
      if (!el.concurrencyChart || !window.Chart) return;
      if (appState.chart) { appState.chart.destroy(); }
      
      const displayData = appState.aggregatedData;
      if (displayData.length === 0) return;
      
      let chartData = displayData;
      if (chartData.length > 200) { 
        chartData = chartData.slice(-200); 
      }
      
      const labels = chartData.map(item => formatIntervalDate(item.interval, appState.currentGranularity));
      const data = chartData.map(item => item.concurrent);
      const threshold = appState.threshold;
      
      appState.chart = new Chart(el.concurrencyChart, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            { 
              label: 'Concurrent Logged-in Users', 
              data: data, 
              borderColor: '#63AB8F', 
              backgroundColor: 'rgba(99, 171, 143, 0.1)', 
              borderWidth: 2, 
              pointRadius: 1, 
              pointHoverRadius: 4, 
              pointBackgroundColor: '#63AB8F', 
              pointBorderColor: '#fff', 
              tension: 0.1, 
              fill: true 
            },
            { 
              label: 'Alert Threshold', 
              data: Array(data.length).fill(threshold), 
              borderColor: '#dc3545', 
              borderWidth: 2, 
              borderDash: [5, 5], 
              pointRadius: 0, 
              fill: false 
            }
          ]
        },
        options: {
          responsive: true, 
          maintainAspectRatio: false,
          interaction: { intersect: false, mode: 'index' },
          plugins: {
            tooltip: {
              callbacks: {
                afterBody: function(context) {
                  const idx = context[0].dataIndex;
                  const item = chartData[idx];
                  if (item.concurrent > threshold) { 
                    return '‚ö†Ô∏è Exceeds threshold!'; 
                  }
                  return '';
                }
              }
            }
          },
          scales: { 
            y: { 
              beginAtZero: true, 
              title: { display: true, text: 'Concurrent Users' } 
            } 
          }
        }
      });
    }

    function renderPeakTable() {
      const tbody = el.peakTableBody;
      tbody.innerHTML = '';
      const displayData = appState.aggregatedData;
      const threshold = appState.threshold;
      const peakData = displayData.filter(item => item.concurrent > threshold).sort((a, b) => b.concurrent - a.concurrent);
      
      if (peakData.length === 0) {
        tbody.innerHTML = `<tr><td colspan="4" style="text-align:center;padding:48px;color:var(--text-light);">No intervals exceed the threshold of ${threshold} concurrent users.</td></tr>`;
        return;
      }
      
      const peak = appState.stats.peakConcurrency;
      peakData.forEach(item => {
        const row = document.createElement('tr');
        const percentage = Math.round((item.concurrent / peak) * 100);
        let statusClass = 'peak-badge', statusText = 'Peak';
        
        if (percentage >= 90) { 
          statusText = 'Critical Peak'; 
        } else if (percentage >= 70) { 
          statusText = 'High Usage'; 
          statusClass = 'high-badge'; 
        } else { 
          statusText = 'Above Threshold'; 
          statusClass = 'high-badge'; 
        }
        
        row.innerHTML = `<td style="font-weight:600;">${formatIntervalDate(item.interval, appState.currentGranularity)}</td>
                         <td style="font-weight:700;color:${percentage >= 90 ? 'var(--danger)' : 'var(--warning)'};">${item.concurrent}</td>
                         <td>${percentage}%</td>
                         <td><span class="${statusClass}">${statusText}</span></td>`;
        tbody.appendChild(row);
      });
    }

    function renderIntervalsTable() {
      const tbody = el.intervalsTableBody;
      tbody.innerHTML = '';
      
      const displayData = appState.aggregatedData;
      if (displayData.length === 0) {
        tbody.innerHTML = `<tr><td colspan="3" style="text-align:center;padding:48px;color:var(--text-light);">No data available. Run concurrency analysis first.</td></tr>`;
        return;
      }
      
      let data = [...displayData];
      const searchTerm = el.searchInterval?.value?.toLowerCase() || '';
      
      if (searchTerm) {
        data = data.filter(item => formatIntervalDate(item.interval, appState.currentGranularity).toLowerCase().includes(searchTerm));
      }
      
      el.visibleIntervals.textContent = data.length;
      el.totalIntervals.textContent = displayData.length;
      
      data.forEach((item, idx) => {
        const prev = idx > 0 ? data[idx - 1].concurrent : item.concurrent;
        const change = item.concurrent - prev;
        const changeIcon = change > 0 ? '‚ñ≤' : change < 0 ? '‚ñº' : '‚óÜ';
        const changeColor = change > 0 ? 'var(--danger)' : change < 0 ? 'var(--success)' : 'var(--text-light)';
        
        const row = document.createElement('tr');
        row.innerHTML = `<td>${formatIntervalDate(item.interval, appState.currentGranularity)}</td>
                         <td style="font-weight:600;color:${item.concurrent > appState.threshold ? 'var(--danger)' : 'inherit'};">${item.concurrent}</td>
                         <td style="color:${changeColor};">${changeIcon} ${change !== 0 ? Math.abs(change) : '0'}</td>`;
        tbody.appendChild(row);
      });
    }

    // ==================== EXPORT ====================
    function exportReport() {
      const displayData = appState.aggregatedData;
      if (!displayData.length) { 
        showStatusMessage('No data to export', 'error'); 
        return; 
      }
      
      let csv = 'Genesys Cloud Concurrency Report - London Region\n';
      csv += `Generated: ${new Date().toLocaleString()}\n`;
      csv += `Environment: London (euw2.pure.cloud)\n`;
      csv += `Period: ${el.dateFrom.value} to ${el.dateTo.value}\n`;
      csv += `Granularity: ${appState.currentGranularity}\n`;
      csv += `Alert Threshold: ${appState.threshold} concurrent users\n`;
      csv += `Total Users Analysed: ${appState.stats.totalUsers}\n`;
      csv += `Peak Concurrency: ${appState.stats.peakConcurrency}\n`;
      csv += `Average Concurrency: ${appState.stats.avgConcurrency}\n`;
      csv += `Total Intervals: ${appState.stats.totalIntervals}\n`;
      csv += `\n`;
      csv += 'PEAK INTERVALS (Exceeding Threshold)\n';
      csv += 'Interval,Concurrent Users,% of Peak,Status\n';
      
      const peakData = displayData.filter(item => item.concurrent > appState.threshold).sort((a, b) => b.concurrent - a.concurrent);
      peakData.forEach(item => {
        const percentage = Math.round((item.concurrent / appState.stats.peakConcurrency) * 100);
        csv += `${item.interval},${item.concurrent},${percentage}%,Above Threshold\n`;
      });
      
      csv += '\nALL INTERVALS\n';
      csv += 'Interval,Concurrent Users,Change\n';
      displayData.forEach((item, idx) => {
        const prev = idx > 0 ? displayData[idx - 1].concurrent : item.concurrent;
        const change = item.concurrent - prev;
        csv += `${item.interval},${item.concurrent},${change > 0 ? '+' : ''}${change}\n`;
      });
      
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const dateStr = new Date().toISOString().split('T')[0];
      a.href = url;
      a.download = `genesys_concurrency_london_report_${dateStr}.csv`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      showStatusMessage('‚úÖ Report exported successfully', 'success');
    }

    function resetApplication() {
      if (confirm('Reset the application? This will clear all data but keep the connection.')) {
        appState.users = []; 
        appState.fifteenMinData = [];
        appState.aggregatedData = [];
        appState.stats = { totalUsers: 0, peakConcurrency: 0, avgConcurrency: 0, totalIntervals: 0, peakInterval: null };
        
        el.statTotalUsers.textContent = '0'; 
        el.statPeakConcurrency.textContent = '0'; 
        el.statAvgConcurrency.textContent = '0'; 
        el.statTotalIntervals.textContent = '0';
        el.peakTimeOverall.textContent = '--:--'; 
        el.peakConcurrencyOverall.textContent = '0 concurrent users';
        el.peakDay.textContent = '--/--/----'; 
        el.peakDayConcurrency.textContent = '0 concurrent users';
        el.peakHour.textContent = '--:--'; 
        el.peakHourConcurrency.textContent = '0 concurrent users';
        
        el.btnFetchConcurrency.disabled = true; 
        el.btnExport.disabled = true;
        
        if (appState.chart) { 
          appState.chart.destroy(); 
          appState.chart = null; 
        }
        
        renderPeakTable(); 
        renderIntervalsTable();
        
        if (el.debugInfo) {
          el.debugInfo.innerHTML = '<strong>Debug:</strong> Reset complete';
        }
        
        showStatusMessage('üîÑ Application reset', 'info');
      }
    }

    // Handle granularity change
    function onGranularityChange(granularity) {
      appState.currentGranularity = granularity;
      localStorage.setItem(STORAGE_KEYS.GRANULARITY, granularity);
      
      if (appState.fifteenMinData.length > 0) {
        // Re-aggregate from 15-minute data
        appState.aggregatedData = aggregateToGranularity(appState.fifteenMinData, granularity);
        
        // Recalculate stats
        let peakConcurrency = 0;
        let totalConcurrency = 0;
        appState.aggregatedData.forEach(item => {
          totalConcurrency += item.concurrent;
          if (item.concurrent > peakConcurrency) peakConcurrency = item.concurrent;
        });
        
        appState.stats.peakConcurrency = peakConcurrency;
        appState.stats.avgConcurrency = appState.aggregatedData.length > 0 ? Math.round(totalConcurrency / appState.aggregatedData.length) : 0;
        appState.stats.totalIntervals = appState.aggregatedData.length;
        
        calculatePeakTimes();
        updateStatsUI();
        renderConcurrencyChart();
        renderPeakTable();
        renderIntervalsTable();
        
        showStatusMessage(`Granularity changed to ${granularity} - aggregated from 15min data`, 'info');
      }
    }

    // ==================== INITIALISATION ====================
    function initializeApp() {
      console.log("Initializing London app...");
      const last7Days = getLast7Days();
      if (el.dateFrom) el.dateFrom.value = last7Days.from;
      if (el.dateTo) el.dateTo.value = last7Days.to;
      updateDateRangeInfo();

      if (el.btnFetchUsers) { el.btnFetchUsers.addEventListener('click', fetchUsers); }
      if (el.btnFetchConcurrency) { el.btnFetchConcurrency.addEventListener('click', fetchConcurrency); }
      if (el.btnExport) { el.btnExport.addEventListener('click', exportReport); }
      if (el.btnReset) { el.btnReset.addEventListener('click', resetApplication); }
      if (el.btnManualAuth) { el.btnManualAuth.addEventListener('click', manualAuth); }

      if (el.granularityOptions) {
        el.granularityOptions.forEach(opt => {
          opt.addEventListener('click', function() {
            el.granularityOptions.forEach(o => o.classList.remove('active'));
            this.classList.add('active');
            onGranularityChange(this.dataset.granularity);
          });
        });
      }

      if (el.thresholdConcurrency) {
        el.thresholdConcurrency.addEventListener('change', function() {
          appState.threshold = parseInt(this.value) || 20;
          localStorage.setItem(STORAGE_KEYS.THRESHOLD, appState.threshold);
          if (el.thresholdValue) el.thresholdValue.textContent = appState.threshold;
          if (appState.aggregatedData.length > 0) {
            renderConcurrencyChart();
            renderPeakTable();
          }
        });
      }

      if (el.searchInterval) { el.searchInterval.addEventListener('input', renderIntervalsTable); }
      if (el.dateFrom) {
        el.dateFrom.addEventListener('change', function() {
          localStorage.setItem(STORAGE_KEYS.DATE_FROM, el.dateFrom.value);
          updateDateRangeInfo();
        });
      }
      if (el.dateTo) {
        el.dateTo.addEventListener('change', function() {
          localStorage.setItem(STORAGE_KEYS.DATE_TO, el.dateTo.value);
          updateDateRangeInfo();
        });
      }
    }

    // ==================== START ====================
    window.onload = function() {
      console.log("London region page loaded, initializing...");
      initAuth();
      initializeApp();
    };
  </script>
</body>
</html>
